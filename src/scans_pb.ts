// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file scans.proto (package scanswift, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Metadata } from "./base_pb.js";

/**
 *
 * Stores the possible values for inferred from
 *
 * @generated from enum scanswift.INFERRED_FROM
 */
export enum INFERRED_FROM {
  /**
   * Inferred from IP address
   *
   * @generated from enum value: INFERRED_FROM_IP_UNSPECIFIED = 0;
   */
  INFERRED_FROM_IP_UNSPECIFIED = 0,

  /**
   * Inferred from user provided location
   *
   * @generated from enum value: INFERRED_FROM_USER = 1;
   */
  INFERRED_FROM_USER = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(INFERRED_FROM)
proto3.util.setEnumType(INFERRED_FROM, "scanswift.INFERRED_FROM", [
  { no: 0, name: "INFERRED_FROM_IP_UNSPECIFIED" },
  { no: 1, name: "INFERRED_FROM_USER" },
]);

/**
 *
 * Describes the data structure to perform the create scan operation using the given IP address for the serial/packaging/shipping denoted by resource_uuid
 *
 * @generated from message scanswift.ScansServiceCreateScanFromIPRequest
 */
export class ScansServiceCreateScanFromIPRequest extends Message<ScansServiceCreateScanFromIPRequest> {
  /**
   * The UUID of the serial or packaging or shipping record
   *
   * @generated from field: string resource_uuid = 10;
   */
  resourceUuid = "";

  /**
   * The IP address using which the location information needs to be determined
   *
   * @generated from field: string ip = 11;
   */
  ip = "";

  constructor(data?: PartialMessage<ScansServiceCreateScanFromIPRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.ScansServiceCreateScanFromIPRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "resource_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "ip", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScansServiceCreateScanFromIPRequest {
    return new ScansServiceCreateScanFromIPRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScansServiceCreateScanFromIPRequest {
    return new ScansServiceCreateScanFromIPRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScansServiceCreateScanFromIPRequest {
    return new ScansServiceCreateScanFromIPRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ScansServiceCreateScanFromIPRequest | PlainMessage<ScansServiceCreateScanFromIPRequest> | undefined, b: ScansServiceCreateScanFromIPRequest | PlainMessage<ScansServiceCreateScanFromIPRequest> | undefined): boolean {
    return proto3.util.equals(ScansServiceCreateScanFromIPRequest, a, b);
  }
}

/**
 *
 * Describes the data structure to perform the create operation on a serial scan
 *
 * @generated from message scanswift.ScansServiceSerialScanCreateRequest
 */
export class ScansServiceSerialScanCreateRequest extends Message<ScansServiceSerialScanCreateRequest> {
  /**
   * The UUID of the serial that needs to be updated
   *
   * @generated from field: string serial_uuid = 10;
   */
  serialUuid = "";

  /**
   * The latitude of the location
   *
   * @generated from field: double latitude = 11;
   */
  latitude = 0;

  /**
   * The longitude of the location
   *
   * @generated from field: double longitude = 12;
   */
  longitude = 0;

  /**
   * Stores if the location has been inferred from IP or from user provided geocoordinates
   *
   * @generated from field: scanswift.INFERRED_FROM inferred_from = 13;
   */
  inferredFrom = INFERRED_FROM.INFERRED_FROM_IP_UNSPECIFIED;

  constructor(data?: PartialMessage<ScansServiceSerialScanCreateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.ScansServiceSerialScanCreateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "serial_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "latitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 12, name: "longitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "inferred_from", kind: "enum", T: proto3.getEnumType(INFERRED_FROM) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScansServiceSerialScanCreateRequest {
    return new ScansServiceSerialScanCreateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScansServiceSerialScanCreateRequest {
    return new ScansServiceSerialScanCreateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScansServiceSerialScanCreateRequest {
    return new ScansServiceSerialScanCreateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ScansServiceSerialScanCreateRequest | PlainMessage<ScansServiceSerialScanCreateRequest> | undefined, b: ScansServiceSerialScanCreateRequest | PlainMessage<ScansServiceSerialScanCreateRequest> | undefined): boolean {
    return proto3.util.equals(ScansServiceSerialScanCreateRequest, a, b);
  }
}

/**
 *
 * Describes the data structure to perform the update operation on a serial scan
 *
 * @generated from message scanswift.ScansServiceSerialScanUpdateRequest
 */
export class ScansServiceSerialScanUpdateRequest extends Message<ScansServiceSerialScanUpdateRequest> {
  /**
   * The UUID of the resource that needs to be updated
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * The latitude of the location
   *
   * @generated from field: double latitude = 11;
   */
  latitude = 0;

  /**
   * The longitude of the location
   *
   * @generated from field: double longitude = 12;
   */
  longitude = 0;

  /**
   * Stores if the location has been inferred from IP or from user provided geocoordinates
   *
   * @generated from field: scanswift.INFERRED_FROM inferred_from = 13;
   */
  inferredFrom = INFERRED_FROM.INFERRED_FROM_IP_UNSPECIFIED;

  constructor(data?: PartialMessage<ScansServiceSerialScanUpdateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.ScansServiceSerialScanUpdateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "latitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 12, name: "longitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "inferred_from", kind: "enum", T: proto3.getEnumType(INFERRED_FROM) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScansServiceSerialScanUpdateRequest {
    return new ScansServiceSerialScanUpdateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScansServiceSerialScanUpdateRequest {
    return new ScansServiceSerialScanUpdateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScansServiceSerialScanUpdateRequest {
    return new ScansServiceSerialScanUpdateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ScansServiceSerialScanUpdateRequest | PlainMessage<ScansServiceSerialScanUpdateRequest> | undefined, b: ScansServiceSerialScanUpdateRequest | PlainMessage<ScansServiceSerialScanUpdateRequest> | undefined): boolean {
    return proto3.util.equals(ScansServiceSerialScanUpdateRequest, a, b);
  }
}

/**
 *
 * Describes the serial scan message
 *
 * @generated from message scanswift.ScansServiceSerialScan
 */
export class ScansServiceSerialScan extends Message<ScansServiceSerialScan> {
  /**
   * Stores the metadata of this resource
   *
   * @generated from field: scanswift.Metadata metadata = 1;
   */
  metadata?: Metadata;

  /**
   * The UUID of the serial
   *
   * @generated from field: string serial_uuid = 10;
   */
  serialUuid = "";

  /**
   * The latitude of the location
   *
   * @generated from field: double latitude = 11;
   */
  latitude = 0;

  /**
   * The longitude of the location
   *
   * @generated from field: double longitude = 12;
   */
  longitude = 0;

  /**
   * Stores if the location has been inferred from IP or from user provided geocoordinates
   *
   * @generated from field: scanswift.INFERRED_FROM inferred_from = 13;
   */
  inferredFrom = INFERRED_FROM.INFERRED_FROM_IP_UNSPECIFIED;

  constructor(data?: PartialMessage<ScansServiceSerialScan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.ScansServiceSerialScan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Metadata },
    { no: 10, name: "serial_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "latitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 12, name: "longitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "inferred_from", kind: "enum", T: proto3.getEnumType(INFERRED_FROM) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScansServiceSerialScan {
    return new ScansServiceSerialScan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScansServiceSerialScan {
    return new ScansServiceSerialScan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScansServiceSerialScan {
    return new ScansServiceSerialScan().fromJsonString(jsonString, options);
  }

  static equals(a: ScansServiceSerialScan | PlainMessage<ScansServiceSerialScan> | undefined, b: ScansServiceSerialScan | PlainMessage<ScansServiceSerialScan> | undefined): boolean {
    return proto3.util.equals(ScansServiceSerialScan, a, b);
  }
}

/**
 *
 * Describes the data structure that stores a list of serial scans
 *
 * @generated from message scanswift.SerialsScansList
 */
export class SerialsScansList extends Message<SerialsScansList> {
  /**
   * List of serial scans
   *
   * @generated from field: repeated scanswift.ScansServiceSerialScan list = 1;
   */
  list: ScansServiceSerialScan[] = [];

  constructor(data?: PartialMessage<SerialsScansList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.SerialsScansList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "message", T: ScansServiceSerialScan, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SerialsScansList {
    return new SerialsScansList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SerialsScansList {
    return new SerialsScansList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SerialsScansList {
    return new SerialsScansList().fromJsonString(jsonString, options);
  }

  static equals(a: SerialsScansList | PlainMessage<SerialsScansList> | undefined, b: SerialsScansList | PlainMessage<SerialsScansList> | undefined): boolean {
    return proto3.util.equals(SerialsScansList, a, b);
  }
}

/**
 *
 * Describes the data structure to perform the create operation on a packaging scan
 *
 * @generated from message scanswift.ScansServicePackagingScanCreateRequest
 */
export class ScansServicePackagingScanCreateRequest extends Message<ScansServicePackagingScanCreateRequest> {
  /**
   * The UUID of the packaging that needs to be updated
   *
   * @generated from field: string packaging_uuid = 10;
   */
  packagingUuid = "";

  /**
   * The latitude of the location
   *
   * @generated from field: double latitude = 11;
   */
  latitude = 0;

  /**
   * The longitude of the location
   *
   * @generated from field: double longitude = 12;
   */
  longitude = 0;

  /**
   * Stores if the location has been inferred from IP or from user provided geocoordinates
   *
   * @generated from field: scanswift.INFERRED_FROM inferred_from = 13;
   */
  inferredFrom = INFERRED_FROM.INFERRED_FROM_IP_UNSPECIFIED;

  constructor(data?: PartialMessage<ScansServicePackagingScanCreateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.ScansServicePackagingScanCreateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "packaging_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "latitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 12, name: "longitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "inferred_from", kind: "enum", T: proto3.getEnumType(INFERRED_FROM) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScansServicePackagingScanCreateRequest {
    return new ScansServicePackagingScanCreateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScansServicePackagingScanCreateRequest {
    return new ScansServicePackagingScanCreateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScansServicePackagingScanCreateRequest {
    return new ScansServicePackagingScanCreateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ScansServicePackagingScanCreateRequest | PlainMessage<ScansServicePackagingScanCreateRequest> | undefined, b: ScansServicePackagingScanCreateRequest | PlainMessage<ScansServicePackagingScanCreateRequest> | undefined): boolean {
    return proto3.util.equals(ScansServicePackagingScanCreateRequest, a, b);
  }
}

/**
 *
 * Describes the data structure to perform the update operation on a packaging scan
 *
 * @generated from message scanswift.ScansServicePackagingScanUpdateRequest
 */
export class ScansServicePackagingScanUpdateRequest extends Message<ScansServicePackagingScanUpdateRequest> {
  /**
   * The UUID of the resource that needs to be updated
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * The latitude of the location
   *
   * @generated from field: double latitude = 11;
   */
  latitude = 0;

  /**
   * The longitude of the location
   *
   * @generated from field: double longitude = 12;
   */
  longitude = 0;

  /**
   * Stores if the location has been inferred from IP or from user provided geocoordinates
   *
   * @generated from field: scanswift.INFERRED_FROM inferred_from = 13;
   */
  inferredFrom = INFERRED_FROM.INFERRED_FROM_IP_UNSPECIFIED;

  constructor(data?: PartialMessage<ScansServicePackagingScanUpdateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.ScansServicePackagingScanUpdateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "latitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 12, name: "longitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "inferred_from", kind: "enum", T: proto3.getEnumType(INFERRED_FROM) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScansServicePackagingScanUpdateRequest {
    return new ScansServicePackagingScanUpdateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScansServicePackagingScanUpdateRequest {
    return new ScansServicePackagingScanUpdateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScansServicePackagingScanUpdateRequest {
    return new ScansServicePackagingScanUpdateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ScansServicePackagingScanUpdateRequest | PlainMessage<ScansServicePackagingScanUpdateRequest> | undefined, b: ScansServicePackagingScanUpdateRequest | PlainMessage<ScansServicePackagingScanUpdateRequest> | undefined): boolean {
    return proto3.util.equals(ScansServicePackagingScanUpdateRequest, a, b);
  }
}

/**
 *
 * Describes the packaging scan message
 *
 * @generated from message scanswift.ScansServicePackagingScan
 */
export class ScansServicePackagingScan extends Message<ScansServicePackagingScan> {
  /**
   * Stores the metadata of this resource
   *
   * @generated from field: scanswift.Metadata metadata = 1;
   */
  metadata?: Metadata;

  /**
   * The UUID of the packaging
   *
   * @generated from field: string packaging_uuid = 10;
   */
  packagingUuid = "";

  /**
   * The latitude of the location
   *
   * @generated from field: double latitude = 11;
   */
  latitude = 0;

  /**
   * The longitude of the location
   *
   * @generated from field: double longitude = 12;
   */
  longitude = 0;

  /**
   * Stores if the location has been inferred from IP or from user provided geocoordinates
   *
   * @generated from field: scanswift.INFERRED_FROM inferred_from = 13;
   */
  inferredFrom = INFERRED_FROM.INFERRED_FROM_IP_UNSPECIFIED;

  constructor(data?: PartialMessage<ScansServicePackagingScan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.ScansServicePackagingScan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Metadata },
    { no: 10, name: "packaging_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "latitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 12, name: "longitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "inferred_from", kind: "enum", T: proto3.getEnumType(INFERRED_FROM) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScansServicePackagingScan {
    return new ScansServicePackagingScan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScansServicePackagingScan {
    return new ScansServicePackagingScan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScansServicePackagingScan {
    return new ScansServicePackagingScan().fromJsonString(jsonString, options);
  }

  static equals(a: ScansServicePackagingScan | PlainMessage<ScansServicePackagingScan> | undefined, b: ScansServicePackagingScan | PlainMessage<ScansServicePackagingScan> | undefined): boolean {
    return proto3.util.equals(ScansServicePackagingScan, a, b);
  }
}

/**
 *
 * Describes the data structure that stores a list of packaging scans
 *
 * @generated from message scanswift.PackagingsScansList
 */
export class PackagingsScansList extends Message<PackagingsScansList> {
  /**
   * List of packaging scans
   *
   * @generated from field: repeated scanswift.ScansServicePackagingScan list = 1;
   */
  list: ScansServicePackagingScan[] = [];

  constructor(data?: PartialMessage<PackagingsScansList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.PackagingsScansList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "message", T: ScansServicePackagingScan, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PackagingsScansList {
    return new PackagingsScansList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PackagingsScansList {
    return new PackagingsScansList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PackagingsScansList {
    return new PackagingsScansList().fromJsonString(jsonString, options);
  }

  static equals(a: PackagingsScansList | PlainMessage<PackagingsScansList> | undefined, b: PackagingsScansList | PlainMessage<PackagingsScansList> | undefined): boolean {
    return proto3.util.equals(PackagingsScansList, a, b);
  }
}

/**
 *
 * Describes the data structure to perform the create operation on a shipping scan
 *
 * @generated from message scanswift.ScansServiceShippingScanCreateRequest
 */
export class ScansServiceShippingScanCreateRequest extends Message<ScansServiceShippingScanCreateRequest> {
  /**
   * The UUID of the shipping that needs to be updated
   *
   * @generated from field: string shipping_uuid = 10;
   */
  shippingUuid = "";

  /**
   * The latitude of the location
   *
   * @generated from field: double latitude = 11;
   */
  latitude = 0;

  /**
   * The longitude of the location
   *
   * @generated from field: double longitude = 12;
   */
  longitude = 0;

  /**
   * Stores if the location has been inferred from IP or from user provided geocoordinates
   *
   * @generated from field: scanswift.INFERRED_FROM inferred_from = 13;
   */
  inferredFrom = INFERRED_FROM.INFERRED_FROM_IP_UNSPECIFIED;

  constructor(data?: PartialMessage<ScansServiceShippingScanCreateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.ScansServiceShippingScanCreateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "shipping_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "latitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 12, name: "longitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "inferred_from", kind: "enum", T: proto3.getEnumType(INFERRED_FROM) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScansServiceShippingScanCreateRequest {
    return new ScansServiceShippingScanCreateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScansServiceShippingScanCreateRequest {
    return new ScansServiceShippingScanCreateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScansServiceShippingScanCreateRequest {
    return new ScansServiceShippingScanCreateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ScansServiceShippingScanCreateRequest | PlainMessage<ScansServiceShippingScanCreateRequest> | undefined, b: ScansServiceShippingScanCreateRequest | PlainMessage<ScansServiceShippingScanCreateRequest> | undefined): boolean {
    return proto3.util.equals(ScansServiceShippingScanCreateRequest, a, b);
  }
}

/**
 *
 * Describes the data structure to perform the update operation on a shipping scan
 *
 * @generated from message scanswift.ScansServiceShippingScanUpdateRequest
 */
export class ScansServiceShippingScanUpdateRequest extends Message<ScansServiceShippingScanUpdateRequest> {
  /**
   * The UUID of the resource that needs to be updated
   *
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * The latitude of the location
   *
   * @generated from field: double latitude = 11;
   */
  latitude = 0;

  /**
   * The longitude of the location
   *
   * @generated from field: double longitude = 12;
   */
  longitude = 0;

  /**
   * Stores if the location has been inferred from IP or from user provided geocoordinates
   *
   * @generated from field: scanswift.INFERRED_FROM inferred_from = 13;
   */
  inferredFrom = INFERRED_FROM.INFERRED_FROM_IP_UNSPECIFIED;

  constructor(data?: PartialMessage<ScansServiceShippingScanUpdateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.ScansServiceShippingScanUpdateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "latitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 12, name: "longitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "inferred_from", kind: "enum", T: proto3.getEnumType(INFERRED_FROM) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScansServiceShippingScanUpdateRequest {
    return new ScansServiceShippingScanUpdateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScansServiceShippingScanUpdateRequest {
    return new ScansServiceShippingScanUpdateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScansServiceShippingScanUpdateRequest {
    return new ScansServiceShippingScanUpdateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ScansServiceShippingScanUpdateRequest | PlainMessage<ScansServiceShippingScanUpdateRequest> | undefined, b: ScansServiceShippingScanUpdateRequest | PlainMessage<ScansServiceShippingScanUpdateRequest> | undefined): boolean {
    return proto3.util.equals(ScansServiceShippingScanUpdateRequest, a, b);
  }
}

/**
 *
 * Describes the shipping scan message
 *
 * @generated from message scanswift.ScansServiceShippingScan
 */
export class ScansServiceShippingScan extends Message<ScansServiceShippingScan> {
  /**
   * Stores the metadata of this resource
   *
   * @generated from field: scanswift.Metadata metadata = 1;
   */
  metadata?: Metadata;

  /**
   * The UUID of the shipping
   *
   * @generated from field: string shipping_uuid = 10;
   */
  shippingUuid = "";

  /**
   * The latitude of the location
   *
   * @generated from field: double latitude = 11;
   */
  latitude = 0;

  /**
   * The longitude of the location
   *
   * @generated from field: double longitude = 12;
   */
  longitude = 0;

  /**
   * Stores if the location has been inferred from IP or from user provided geocoordinates
   *
   * @generated from field: scanswift.INFERRED_FROM inferred_from = 13;
   */
  inferredFrom = INFERRED_FROM.INFERRED_FROM_IP_UNSPECIFIED;

  constructor(data?: PartialMessage<ScansServiceShippingScan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.ScansServiceShippingScan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Metadata },
    { no: 10, name: "shipping_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "latitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 12, name: "longitude", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "inferred_from", kind: "enum", T: proto3.getEnumType(INFERRED_FROM) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScansServiceShippingScan {
    return new ScansServiceShippingScan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScansServiceShippingScan {
    return new ScansServiceShippingScan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScansServiceShippingScan {
    return new ScansServiceShippingScan().fromJsonString(jsonString, options);
  }

  static equals(a: ScansServiceShippingScan | PlainMessage<ScansServiceShippingScan> | undefined, b: ScansServiceShippingScan | PlainMessage<ScansServiceShippingScan> | undefined): boolean {
    return proto3.util.equals(ScansServiceShippingScan, a, b);
  }
}

/**
 *
 * Describes the data structure that stores a list of shipping scans
 *
 * @generated from message scanswift.ShippingsScansList
 */
export class ShippingsScansList extends Message<ShippingsScansList> {
  /**
   * List of shipping scans
   *
   * @generated from field: repeated scanswift.ScansServiceShippingScan list = 1;
   */
  list: ScansServiceShippingScan[] = [];

  constructor(data?: PartialMessage<ShippingsScansList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "scanswift.ShippingsScansList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "message", T: ScansServiceShippingScan, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShippingsScansList {
    return new ShippingsScansList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShippingsScansList {
    return new ShippingsScansList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShippingsScansList {
    return new ShippingsScansList().fromJsonString(jsonString, options);
  }

  static equals(a: ShippingsScansList | PlainMessage<ShippingsScansList> | undefined, b: ShippingsScansList | PlainMessage<ShippingsScansList> | undefined): boolean {
    return proto3.util.equals(ShippingsScansList, a, b);
  }
}

